Common questions:

*
Because of the same distance happens to be at distinct curve points where f is different.
(ğ‘“ = ğœ…MÂ²/(rÂ²ğ›ºÂ³), (s) Kepler task, addendum. ğœ… and ğ›º are different at these points.)


*
draft: fQR and sagitta by time:
In this application, in context of Kepler motion, there are two ways of estimation the force. One is by time 1) ğ—³ = dÂ²ğ—¿/dtÂ². Other one is 2) ğ—³ = lim ğ—¤ğ—¥/(QT*SP)Â². In the latter one, we set Î”q, calculate ğ—¤=ğ—¿(q+Î”q), ğ—£=ğ—¿(q) and make calculation. In this case q is called a free variable.

In the first one method, we set Î”t and calculate (integrate) Î”q = q(t+Î”t)-q(t), ğ—¤=ğ—¿(q(t)+Î”q), ğ—£=ğ—¿(q(t)). In this case, t is free variable.

In process of converging, (1) and (2) (even if normed by max) usually are different functions of r. This is why we have two branches on graph.

Î”Â²ğ—¿/Î”tÂ² is an approximated sagitta, ğ—¤ğ—¥ is a displacement. For sagitta, we extend Î”t to both sides from t, to t-Î”t/2 and t+Î”t/2 or to Q and Q-.

*
Free variables. (do fix spelling)

Free variable is a math. jargon to emphasize the context in which curve is being calculated.

In prop. 6 curve is Bezier (see mat.calculate_divided_differences) and "free" parameter "q" is in Bezier formula ğ—¿(q) = ğ—£1*q(q-q1)(q-q2)... + ğ—£2*(q-q1)*...
However, when sagitta is being calculated, then time t is considered as a "free" variable:
sagitta = (ğ—¿(t+dt) + ğ—¿(t-dt))/2. 

In prop. 7, the free variable "q" used when building the curve is an angle.

In context of calculating fQR, it is irrelevant which variable to use, so the same angle is used. ğ—³QR = [ğ—¤(q+dq) - ğ—¥(q+dq)]/area.

In prop. 9 of "exponential curve", curve is constructed (config-functions.js) by formula:
var ro = ro0*Math.exp( A*q ), ğ—¿ = (ro * Math.cos( q ) + center[0], ... ), where q is an angle.

The same variable q is used for fQR.

In prop. 10, q is an angle in "polar" formula for an ellipse centered at ellipse center:
        function q2xy( q )
        {
            q += fi0;
            return [
                A * Math.cos( q ) + center[0],
                B * Math.sin( q ) + center[1],
            ];
        }

In prop. 6 one can require to draw the graph f(s), whare s is a path of the body along the curve. This is a very common choice of curve variable.

Note, drawing the force as a function of "distance", does not represent curve as a function because curve can have multiple points at the same distance.

*
Programming.

In popular app version, as of Nov. 11, 2025. (branch f_ulitmate_max), the estimated and ultimate force is calculated as ğ—³QR = [ğ—¤(q+Î”q) - ğ—¥(q+Î”q)]/areaÂ² = ğ—¤ğ—¥/(QT*SP)Â²=

= stdMod.calcs__displacement() in builds-displacement.js 

The name "calcs__displacement" is misleading. It is a legacy name, which needs work to change. 

I named "popular app version" the version without addendums and "research app version" (branch addk) with addendums.

PS: In book units (lemmas, propositions) with sagitta, sagitta can be used as an alternative way to calculate a force: = sagitta (ğ—¿(t+Î”t) + ğ—¿(t-Î”t))/2.

PS: as of Nov 11, 2025, in branch f_ulitmate_max, all propositions P6,7,9,10,11,12,13 do
calculate festimated as ğ—³QR and fultimate as ultimate ğ—³QR from
var fQR = Math.abs( calcs__displacement(...

P6,7,9,10 11, do use micro framework stdMod.initiates_orbit8graph().
But, in prop 12, 13, fQR calculates in buildsforceGraphArray() in /contents/b1sec3prop12/graph-array.js






